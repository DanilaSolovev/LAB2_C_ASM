
#include <stdio.h>		/* Заголовочный файл объявляет несколько целочисленных типов и макросов */
#include <stdint.h>		/* Заголовочный файл объявляет несколько целочисленных типов и макросов */
/*
ЗАДАНИЕ:
Найти среднее значение положительных элементов с четным индексом. 
*/
// Инициализируем первичный массив с числами
int32_t array_original [] = {2,-9,8,7,-2,8,0,9,5,6,5,-1};
//extern int32_t array_originalB;
int32_t array_originalB [] = {2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1};
int8_t array_original_asm [] = {2,-9,8,7,-2,8,0,9,5,6,5,-1};
int8_t array_originalB_asm [] = {2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1,2,-9,8,7,-2,8,0,9,5,6,5,-1};
//extern int8_t array_originalB_asm [];
// Инициализируем указатель на ответ. Начальное значение NULL
int32_t res = NULL;	

// Объявляем прототип функции, которая будет давать ответ
int32_t array_res (int32_t* array_ptr, size_t array_size);

// Объявляем прототип функции, которая будет определять элементы массива с четным индексом
int32_t* array_chet (int32_t* array_ptr, size_t array_size, int32_t* newmas);

// Объявляем прототип функции, которая будет определять положительные элементы массива
int32_t* array_poloj (int32_t* array_ptr, size_t array_size, int32_t* newmas);

// Объявляем прототип функции, которая будет  выводить среднее значение
int32_t avgres (int32_t* array_ptr, size_t array_size);
	
//Экспортируем функцию	из main.s написанную на ассемблере.	
extern int8_t array_res_asm (int32_t* array_ptr, size_t array_size);

int main (void)
{
	/*Вызываем функцию array_treatment. 
	Функция возвратит указатель на массив соответствующий заданию. 
	Размерность массива такая же как у оригинального массива.*/
	
	res = array_res(array_original, sizeof(array_original)/sizeof(int32_t));
	res = array_res(array_originalB, sizeof(array_originalB)/sizeof(int32_t));
	/*Вызываем функцию array_treatment_asm, тело которой описано в файле main_1.s. 
	Так как, в языке ассемблера не функций malloc() и вообще нет механизма выделения данных из кучи, 
	то мы заранее выделяем место в оперативной памяти для обработанного массива, 
	поэтому нам необходимо передать адрес нового массива в функцию. 
	Размерность массива такая же как у оригинального массива.*/
	
    volatile int8_t res_asm = 0;
    res_asm = array_res_asm (array_original_asm, sizeof(array_original_asm)/sizeof(int8_t));
    res_asm = array_res_asm (array_originalB_asm, sizeof(array_originalB_asm)/sizeof(int8_t));
	while (1)
	{
	}
	return 0;
}

/********************************************************************************/
/*Функция формирующая массив array_chet[], в котором находятся элементы с четными индексами.*/
/********************************************************************************/
/*
Функция принимает:
	int32_t* array_ptr - указатель на исходный массив с элементами типа int32_t
	array_size				 - размер массива
Функция возвращает:
	указатель на область памяти в котором лежит новый массив
*/

int32_t array_res (int32_t* array_ptr, size_t array_size)
{

	int32_t *new_array = NULL;
    int32_t *new_array1 = NULL;
    int32_t *mas_poloj = NULL;
    //int32_t res = NULL;
    new_array =  (int32_t*) (malloc(array_size*sizeof(int32_t)));
    new_array1 =  (int32_t*) (malloc(array_size*sizeof(int32_t)));
   
    int32_t chet_size = array_chet(array_ptr, array_size,  new_array);
	
    int32_t poloj_size = array_poloj(new_array, chet_size, new_array1);
    
    res = array_avgres(new_array1, poloj_size);

    return res;
}

/*Функция формирующая массив mas_chet[], в котором находятся элементы с четными индексами.*/
/********************************************************************************/
/*
Функция принимает:
	int32_t* array_ptr - указатель на исходный массив с элементами типа int32_t
	array_size				 - размер массива
Функция возвращает:
	указатель на область памяти в котором лежит новый массив
*/
int32_t* array_chet (int32_t* array_ptr, size_t array_size, int32_t* new_array1)
{
    int32_t i = 0;
    int32_t a = 0;
    
    while (i < array_size)
    {
        if (i%2==0) 
        {
            *(new_array1+a) = *(array_ptr+i);    
            a++;
        }
    i++;
    }
    return a;
}

/*Функция формирующая массив mas_poloj[], в котором находятся положительные элементы.*/
/********************************************************************************/
/*
Функция принимает:
	int32_t* array_ptr - указатель на исходный массив с элементами типа int32_t
	array_size				 - размер массива
Функция возвращает:
	указатель на область памяти в котором лежит новый массив
*/

int32_t* array_poloj (int32_t* array_ptr, size_t array_size, int32_t* new_array2)
{
    int32_t i = 0;
    int32_t a = 0;
    
    while (i < array_size)
    {
        if (*(array_ptr+i)>=NULL) 
        {
            *(new_array2+a) = *(array_ptr+i);    
            a++;
        }
    i++;
    }
    return a;
}


/********************************************************************************/
/*Функция рассчитывает среднее значение элементов массива*/
/********************************************************************************/
/*
Функция принимает:
	int32_t* array_ptr - указатель на исходный массив с элементами типа int32_t
	array_size				 - размер массива
Функция возвращает:
	среднее значение элементов массива
*/
int32_t array_avgres (int32_t* array_ptr, size_t array_size)
{
	int32_t res = 0;
    int32_t sum = 0;
	int32_t i = 0;
	
	while (i < array_size)
	{
		sum = sum + *(array_ptr+i);
		i++;
	}
    res = sum/i;
	return res;
}
/********************************************************************************/
